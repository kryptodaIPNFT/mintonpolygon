{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _asyncIterator = require(\"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncIterator\");\n\nvar multibase = require('multibase');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar log = require('debug')('ipfs-http-client:pubsub:subscribe');\n\nvar SubscriptionTracker = require('./subscription-tracker');\n\nvar configure = require('../lib/configure');\n\nvar toUrlSearchParams = require('../lib/to-url-search-params');\n\nmodule.exports = configure(function (api, options) {\n  var subsTracker = SubscriptionTracker.singleton();\n\n  var publish = require('./publish')(options);\n\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(topic, handler) {\n      var options,\n          res,\n          ffWorkaround,\n          _args2 = arguments;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n              options.signal = subsTracker.subscribe(topic, handler, options.signal);\n              // In Firefox, the initial call to fetch does not resolve until some data\n              // is received. If this doesn't happen within 1 second send an empty message\n              // to kickstart the process.\n              ffWorkaround = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        log(\"Publishing empty message to \\\"\".concat(topic, \"\\\" to resolve subscription request\"));\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return publish(topic, Buffer.alloc(0), options);\n\n                      case 4:\n                        _context.next = 9;\n                        break;\n\n                      case 6:\n                        _context.prev = 6;\n                        _context.t0 = _context[\"catch\"](1);\n                        log('Failed to publish empty message', _context.t0);\n\n                      case 9:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 6]]);\n              })), 1000);\n              _context2.prev = 3;\n              _context2.next = 6;\n              return api.post('pubsub/sub', {\n                timeout: options.timeout,\n                signal: options.signal,\n                searchParams: toUrlSearchParams(_objectSpread({\n                  arg: topic\n                }, options)),\n                headers: options.headers\n              });\n\n            case 6:\n              res = _context2.sent;\n              _context2.next = 13;\n              break;\n\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](3);\n              // Initial subscribe fail, ensure we clean up\n              subsTracker.unsubscribe(topic, handler);\n              throw _context2.t0;\n\n            case 13:\n              clearTimeout(ffWorkaround);\n              readMessages(res.ndjson(), {\n                onMessage: handler,\n                onEnd: function onEnd() {\n                  return subsTracker.unsubscribe(topic, handler);\n                },\n                onError: options.onError\n              });\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[3, 9]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n});\n\nfunction readMessages(_x3, _x4) {\n  return _readMessages.apply(this, arguments);\n}\n\nfunction _readMessages() {\n  _readMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(msgStream, _ref3) {\n    var onMessage, onEnd, onError, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, msg;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            onMessage = _ref3.onMessage, onEnd = _ref3.onEnd, onError = _ref3.onError;\n            onError = onError || log;\n            _context3.prev = 2;\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context3.prev = 5;\n            _iterator = _asyncIterator(msgStream);\n\n          case 7:\n            _context3.next = 9;\n            return _iterator.next();\n\n          case 9:\n            _step = _context3.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context3.next = 13;\n            return _step.value;\n\n          case 13:\n            _value = _context3.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context3.next = 20;\n              break;\n            }\n\n            msg = _value;\n\n            try {\n              onMessage({\n                from: multibase.encode('base58btc', Buffer.from(msg.from, 'base64')).toString().slice(1),\n                data: Buffer.from(msg.data, 'base64'),\n                seqno: Buffer.from(msg.seqno, 'base64'),\n                topicIDs: msg.topicIDs\n              });\n            } catch (err) {\n              err.message = \"Failed to parse pubsub message: \".concat(err.message);\n              onError(err, false, msg); // Not fatal\n            }\n\n          case 17:\n            _iteratorNormalCompletion = true;\n            _context3.next = 7;\n            break;\n\n          case 20:\n            _context3.next = 26;\n            break;\n\n          case 22:\n            _context3.prev = 22;\n            _context3.t0 = _context3[\"catch\"](5);\n            _didIteratorError = true;\n            _iteratorError = _context3.t0;\n\n          case 26:\n            _context3.prev = 26;\n            _context3.prev = 27;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context3.next = 31;\n              break;\n            }\n\n            _context3.next = 31;\n            return _iterator.return();\n\n          case 31:\n            _context3.prev = 31;\n\n            if (!_didIteratorError) {\n              _context3.next = 34;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 34:\n            return _context3.finish(31);\n\n          case 35:\n            return _context3.finish(26);\n\n          case 36:\n            _context3.next = 41;\n            break;\n\n          case 38:\n            _context3.prev = 38;\n            _context3.t1 = _context3[\"catch\"](2);\n\n            // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n            // Temporarily use the name property instead.\n            if (_context3.t1.type !== 'aborted' && _context3.t1.name !== 'AbortError') {\n              onError(_context3.t1, true); // Fatal\n            }\n\n          case 41:\n            _context3.prev = 41;\n            onEnd();\n            return _context3.finish(41);\n\n          case 44:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[2, 38, 41, 44], [5, 22, 26, 36], [27,, 31, 35]]);\n  }));\n  return _readMessages.apply(this, arguments);\n}","map":{"version":3,"sources":["C:/Users/hndls/matic-nft-tutorial/node_modules/ipfs-http-client/src/pubsub/subscribe.js"],"names":["multibase","require","Buffer","log","SubscriptionTracker","configure","toUrlSearchParams","module","exports","api","options","subsTracker","singleton","publish","topic","handler","signal","subscribe","ffWorkaround","setTimeout","alloc","post","timeout","searchParams","arg","headers","res","unsubscribe","clearTimeout","readMessages","ndjson","onMessage","onEnd","onError","msgStream","msg","from","encode","toString","slice","data","seqno","topicIDs","err","message","type","name"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multibase = require('multibase')\nconst { Buffer } = require('buffer')\nconst log = require('debug')('ipfs-http-client:pubsub:subscribe')\nconst SubscriptionTracker = require('./subscription-tracker')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\nmodule.exports = configure((api, options) => {\n  const subsTracker = SubscriptionTracker.singleton()\n  const publish = require('./publish')(options)\n\n  return async (topic, handler, options = {}) => {\n    options.signal = subsTracker.subscribe(topic, handler, options.signal)\n\n    let res\n\n    // In Firefox, the initial call to fetch does not resolve until some data\n    // is received. If this doesn't happen within 1 second send an empty message\n    // to kickstart the process.\n    const ffWorkaround = setTimeout(async () => {\n      log(`Publishing empty message to \"${topic}\" to resolve subscription request`)\n      try {\n        await publish(topic, Buffer.alloc(0), options)\n      } catch (err) {\n        log('Failed to publish empty message', err)\n      }\n    }, 1000)\n\n    try {\n      res = await api.post('pubsub/sub', {\n        timeout: options.timeout,\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          arg: topic,\n          ...options\n        }),\n        headers: options.headers\n      })\n    } catch (err) { // Initial subscribe fail, ensure we clean up\n      subsTracker.unsubscribe(topic, handler)\n      throw err\n    }\n\n    clearTimeout(ffWorkaround)\n\n    readMessages(res.ndjson(), {\n      onMessage: handler,\n      onEnd: () => subsTracker.unsubscribe(topic, handler),\n      onError: options.onError\n    })\n  }\n})\n\nasync function readMessages (msgStream, { onMessage, onEnd, onError }) {\n  onError = onError || log\n\n  try {\n    for await (const msg of msgStream) {\n      try {\n        onMessage({\n          from: multibase.encode('base58btc', Buffer.from(msg.from, 'base64')).toString().slice(1),\n          data: Buffer.from(msg.data, 'base64'),\n          seqno: Buffer.from(msg.seqno, 'base64'),\n          topicIDs: msg.topicIDs\n        })\n      } catch (err) {\n        err.message = `Failed to parse pubsub message: ${err.message}`\n        onError(err, false, msg) // Not fatal\n      }\n    }\n  } catch (err) {\n    // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n    // Temporarily use the name property instead.\n    if (err.type !== 'aborted' && err.name !== 'AbortError') {\n      onError(err, true) // Fatal\n    }\n  } finally {\n    onEnd()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
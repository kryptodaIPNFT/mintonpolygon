{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _objectWithoutProperties from \"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"C:\\\\Users\\\\hndls\\\\matic-nft-tutorial\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport SturdyWebSocket from 'sturdy-websocket';\nimport CryptoEs from 'crypto-es';\nvar networks = {\n  bitcoin: {\n    '1': 'main',\n    '2': 'testnet'\n  },\n  ethereum: {\n    '1': 'main',\n    '3': 'ropsten',\n    '4': 'rinkeby',\n    '5': 'goerli',\n    '42': 'kovan',\n    '100': 'xdai'\n  }\n};\nvar DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nvar QUEUE_LIMIT = 10000;\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function on(eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(\"\".concat(eventCode, \" is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk\"));\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    emit: function emit(state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, time);\n  });\n}\n\nfunction transaction(hash, id) {\n  var _transaction;\n\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  var startTime = Date.now(); // create emitter for transaction\n\n  var emitter = createEmitter(); // create eventCode for transaction\n\n  var eventCode = 'txSent'; // put in queue\n\n  this._watchedTransactions.push({\n    hash: hash,\n    emitter: emitter\n  });\n\n  var transaction = (_transaction = {}, _defineProperty(_transaction, this._system === 'ethereum' ? 'hash' : 'txid', hash), _defineProperty(_transaction, \"id\", id || hash), _defineProperty(_transaction, \"startTime\", startTime), _defineProperty(_transaction, \"status\", 'sent'), _transaction);\n\n  var newState = _objectSpread(_objectSpread({}, transaction), {}, {\n    eventCode: eventCode\n  }); // logEvent to server\n\n\n  this._sendMessage({\n    eventCode: eventCode,\n    categoryCode: 'activeTransaction',\n    transaction: transaction\n  });\n\n  var transactionObj = {\n    details: transaction,\n    emitter: emitter\n  };\n\n  function emitState() {\n    var emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(function (handler) {\n      return handler({\n        transaction: newState,\n        emitterResult: emitterResult\n      });\n    });\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  var emitter = createEmitter(); // create eventCode for transaction\n\n  var eventCode = 'watch';\n\n  var existingAddressWatcher = this._watchedAccounts.find(function (ac) {\n    return ac.address === address;\n  });\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this._watchedAccounts.push({\n      address: address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode: eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address: address\n    }\n  });\n\n  return {\n    emitter: emitter,\n    details: {\n      address: address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  var address = isAddress(this._system, addressOrHash);\n  var txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    var normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this._watchedAccounts = this._watchedAccounts.filter(function (ac) {\n      return ac.address !== normalizedAddress;\n    }); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    var _transaction2;\n\n    // remove transaction from transactions\n    this._watchedTransactions = this._watchedTransactions.filter(function (tx) {\n      return tx.hash !== addressOrHash;\n    }); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction: (_transaction2 = {}, _defineProperty(_transaction2, this._system === 'ethereum' ? 'hash' : 'txid', addressOrHash), _defineProperty(_transaction2, \"id\", addressOrHash), _defineProperty(_transaction2, \"status\", 'unsubscribed'), _transaction2)\n    });\n  } else {\n    throw new Error(\"Error trying to unsubscribe \".concat(addressOrHash, \": not a valid address or transaction id/hash\"));\n  }\n}\n\nvar version = \"2.1.5\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(\"Queue limit of \".concat(QUEUE_LIMIT, \" messages has been reached.\"));\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nfunction processQueue() {\n  return _processQueue.apply(this, arguments);\n}\n\nfunction _processQueue() {\n  _processQueue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var msg, delay;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            this._processingQueue = true;\n\n            if (this._connected) {\n              _context.next = 4;\n              break;\n            }\n\n            _context.next = 4;\n            return waitForConnectionOpen.bind(this)();\n\n          case 4:\n            if (!(this._queuedMessages.length > 0)) {\n              _context.next = 18;\n              break;\n            }\n\n            _context.next = 7;\n            return wait(1);\n\n          case 7:\n            if (!(this._waitToRetry !== null)) {\n              _context.next = 11;\n              break;\n            }\n\n            _context.next = 10;\n            return this._waitToRetry;\n\n          case 10:\n            this._waitToRetry = null;\n\n          case 11:\n            msg = this._queuedMessages.shift();\n            delay = this._limitRules.duration / this._limitRules.points * 1000;\n            _context.next = 15;\n            return wait(delay);\n\n          case 15:\n            this._socket.send(msg);\n\n            _context.next = 4;\n            break;\n\n          case 18:\n            this._processingQueue = false;\n            this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n\n          case 20:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  return _processQueue.apply(this, arguments);\n}\n\nfunction handleMessage(msg) {\n  var _JSON$parse = JSON.parse(msg.data),\n      status = _JSON$parse.status,\n      reason = _JSON$parse.reason,\n      event = _JSON$parse.event,\n      connectionId = _JSON$parse.connectionId,\n      retryMs = _JSON$parse.retryMs,\n      limitRules = _JSON$parse.limitRules,\n      blockedMsg = _JSON$parse.blockedMsg;\n\n  if (connectionId) {\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit')) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      var _reason = \"\".concat(event.transaction.txid, \" is an invalid txid\");\n\n      if (this._onerror) {\n        this._onerror({\n          message: _reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(_reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      var _reason2 = \"\".concat(event.transaction.hash, \" is an invalid transaction hash\");\n\n      if (this._onerror) {\n        this._onerror({\n          message: _reason2,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(_reason2);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      var _reason3 = \"\".concat(event.account.address, \" is an invalid address\");\n\n      if (this._onerror) {\n        this._onerror({\n          message: _reason3,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(_reason3);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.transaction) {\n    var _transaction3 = event.transaction,\n        eventCode = event.eventCode,\n        contractCall = event.contractCall; // flatten in to one object\n\n    var newState = this._system === 'ethereum' ? _objectSpread(_objectSpread({}, _transaction3), {}, {\n      eventCode: eventCode,\n      contractCall: contractCall\n    }) : _objectSpread(_objectSpread({}, _transaction3), {}, {\n      eventCode: eventCode\n    }); // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || _transaction3.status === 'unsubscribed') {\n      return;\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this._watchedTransactions = this._watchedTransactions.map(function (tx) {\n        if (tx.hash === _transaction3.originalHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = _transaction3.hash || _transaction3.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    var watchedAddress = _transaction3.watchedAddress && this._system === 'ethereum' ? _transaction3.watchedAddress.toLowerCase() : _transaction3.watchedAddress;\n\n    if (watchedAddress) {\n      var accountObj = this._watchedAccounts.find(function (ac) {\n        return ac.address === watchedAddress;\n      });\n\n      var emitterResult = accountObj ? last(accountObj.emitters.map(function (emitter) {\n        return emitter.emit(newState);\n      })) : false;\n\n      this._transactionHandlers.forEach(function (handler) {\n        return handler({\n          transaction: newState,\n          emitterResult: emitterResult\n        });\n      });\n    } else {\n      var transactionObj = this._watchedTransactions.find(function (tx) {\n        return tx.hash === _transaction3.hash || _transaction3.txid;\n      });\n\n      var _emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(function (handler) {\n        return handler({\n          transaction: newState,\n          emitterResult: _emitterResult\n        });\n      });\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify(_objectSpread({\n    timeStamp: new Date(),\n    dappId: this._dappId,\n    version: version,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    }\n  }, msg));\n}\n\nfunction waitForConnectionOpen() {\n  var _this = this;\n\n  return new Promise(function (resolve) {\n    var interval = setInterval(function () {\n      if (_this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nfunction validateType(options) {\n  var name = options.name,\n      value = options.value,\n      type = options.type,\n      optional = options.optional,\n      customValidation = options.customValidation;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(\"\\\"\".concat(name, \"\\\" is required\"));\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(\"\\\"\".concat(name, \"\\\" must be of type: \").concat(type, \", received type: \").concat(typeof value, \" from value: \").concat(value));\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(\"\\\"\".concat(value, \"\\\" is not a valid \\\"\").concat(name, \"\\\"\"));\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n\n  var dappId = options.dappId,\n      system = options.system,\n      name = options.name,\n      networkId = options.networkId,\n      transactionHandlers = options.transactionHandlers,\n      apiUrl = options.apiUrl,\n      ws = options.ws,\n      onopen = options.onopen,\n      ondown = options.ondown,\n      onreopen = options.onreopen,\n      onerror = options.onerror,\n      onclose = options.onclose,\n      otherParams = _objectWithoutProperties(options, [\"dappId\", \"system\", \"name\", \"networkId\", \"transactionHandlers\", \"apiUrl\", \"ws\", \"onopen\", \"ondown\", \"onreopen\", \"onerror\", \"onclose\"]);\n\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string'\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(function (handler) {\n      return validateType({\n        name: 'transactionHandler',\n        value: handler,\n        type: 'function'\n      });\n    });\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  var invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(\"\".concat(invalid[0], \" is not a valid parameter for \").concat(functionName, \", must be one of the following valid parameters: \").concat(validParams.join(', ')));\n  }\n}\n\nvar DEFAULT_NAME = 'unknown';\nvar DEFAULT_SYSTEM = 'ethereum';\n\nvar Blocknative = function Blocknative(options) {\n  var _this2 = this;\n\n  _classCallCheck(this, Blocknative);\n\n  validateOptions(options);\n  var dappId = options.dappId,\n      _options$system = options.system,\n      system = _options$system === void 0 ? DEFAULT_SYSTEM : _options$system,\n      _options$name = options.name,\n      name = _options$name === void 0 ? DEFAULT_NAME : _options$name,\n      networkId = options.networkId,\n      _options$transactionH = options.transactionHandlers,\n      transactionHandlers = _options$transactionH === void 0 ? [] : _options$transactionH,\n      apiUrl = options.apiUrl,\n      ws = options.ws,\n      onopen = options.onopen,\n      ondown = options.ondown,\n      onreopen = options.onreopen,\n      onerror = options.onerror,\n      onclose = options.onclose;\n  var socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n    wsConstructor: ws\n  } : {});\n  socket.onopen = onOpen.bind(this, onopen);\n  socket.ondown = onDown.bind(this, ondown);\n  socket.onreopen = onReopen.bind(this, onreopen);\n  socket.onmessage = handleMessage.bind(this);\n\n  socket.onerror = function (error) {\n    return onerror && onerror({\n      message: 'There was a WebSocket error',\n      error: error\n    });\n  };\n\n  socket.onclose = function () {\n    _this2._pingTimeout && clearInterval(_this2._pingTimeout);\n    onclose && onclose();\n  };\n\n  var storageKey = CryptoEs.SHA1(\"\".concat(dappId, \" - \").concat(name)).toString();\n  var storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);\n  this._storageKey = storageKey;\n  this._connectionId = storedConnectionId || undefined;\n  this._dappId = dappId;\n  this._system = system;\n  this._networkId = networkId;\n  this._transactionHandlers = transactionHandlers;\n  this._socket = socket;\n  this._connected = false;\n  this._sendMessage = sendMessage.bind(this);\n  this._watchedTransactions = [];\n  this._watchedAccounts = [];\n  this._pingTimeout = undefined;\n  this._destroyed = false;\n  this._onerror = onerror;\n  this._queuedMessages = [];\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n  this._waitToRetry = null;\n  this._processingQueue = false;\n  this._processQueue = processQueue.bind(this);\n\n  if (this._socket.ws.on) {\n    this._heartbeat = function () {\n      _this2._pingTimeout && clearTimeout(_this2._pingTimeout);\n      _this2._pingTimeout = setTimeout(function () {\n        // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n        // Sturdy Websocket will handle the new connection logic\n        _this2._socket.ws.terminate();\n      }, 30000 + 1000);\n    };\n\n    this._socket.ws.on('ping', function () {\n      _this2._heartbeat && _this2._heartbeat();\n    });\n  } // public API\n\n\n  this.transaction = transaction.bind(this);\n  this.account = account.bind(this);\n  this.event = event.bind(this);\n  this.unsubscribe = unsubscribe.bind(this);\n\n  this.destroy = function () {\n    _this2._socket.close();\n\n    _this2._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n    // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n    _this2._socket.onclose();\n  };\n};\n\nfunction onOpen(handler) {\n  this._connected = true;\n  var msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nfunction onReopen(handler) {\n  var _this3 = this;\n\n  this._connected = true;\n  var msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n\n  this._watchedAccounts.forEach(function (account) {\n    _this3._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', function () {\n      _this3._heartbeat && _this3._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\nexport default Blocknative;","map":{"version":3,"sources":["C:/Users/hndls/matic-nft-tutorial/node_modules/bnc-sdk/dist/esm/index.js"],"names":["SturdyWebSocket","CryptoEs","networks","bitcoin","ethereum","DEFAULT_RATE_LIMIT_RULES","points","duration","QUEUE_LIMIT","createEmitter","listeners","on","eventCode","listener","Error","emit","state","all","networkName","blockchain","id","serverEcho","last","arr","reverse","isAddress","addressOrHash","length","isTxid","wait","time","Promise","resolve","setTimeout","transaction","hash","_destroyed","startTime","Date","now","emitter","_watchedTransactions","push","_system","newState","_sendMessage","categoryCode","transactionObj","details","emitState","emitterResult","_transactionHandlers","forEach","handler","bind","account","address","toLowerCase","existingAddressWatcher","_watchedAccounts","find","ac","emitters","event","eventObj","unsubscribe","txid","normalizedAddress","filter","tx","version","sendMessage","msg","_queuedMessages","createEventLog","_processingQueue","_processQueue","processQueue","_connected","waitForConnectionOpen","_waitToRetry","shift","delay","_limitRules","_socket","send","handleMessage","JSON","parse","data","status","reason","connectionId","retryMs","limitRules","blockedMsg","window","localStorage","setItem","_storageKey","_connectionId","includes","unshift","_onerror","message","contractCall","map","originalHash","watchedAddress","accountObj","stringify","timeStamp","dappId","_dappId","system","network","_networkId","interval","setInterval","clearInterval","validateType","options","name","value","type","optional","customValidation","Array","isArray","validateOptions","networkId","transactionHandlers","apiUrl","ws","onopen","ondown","onreopen","onerror","onclose","otherParams","invalidParams","validSystem","params","validParams","functionName","invalid","Object","keys","join","DEFAULT_NAME","DEFAULT_SYSTEM","Blocknative","socket","wsConstructor","onOpen","onDown","onReopen","onmessage","error","_pingTimeout","storageKey","SHA1","toString","storedConnectionId","getItem","undefined","_heartbeat","clearTimeout","terminate","destroy","close","closeEvent"],"mappings":"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","sourcesContent":["import SturdyWebSocket from 'sturdy-websocket';\nimport CryptoEs from 'crypto-es';\nconst networks = {\n  bitcoin: {\n    '1': 'main',\n    '2': 'testnet'\n  },\n  ethereum: {\n    '1': 'main',\n    '3': 'ropsten',\n    '4': 'rinkeby',\n    '5': 'goerli',\n    '42': 'kovan',\n    '100': 'xdai'\n  }\n};\nconst DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nconst QUEUE_LIMIT = 10000;\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this._watchedTransactions.push({\n    hash,\n    emitter\n  });\n\n  const transaction = {\n    [this._system === 'ethereum' ? 'hash' : 'txid']: hash,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: transaction,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n\n  const existingAddressWatcher = this._watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this._watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this._watchedAccounts = this._watchedAccounts.filter(ac => ac.address !== normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this._watchedTransactions = this._watchedTransactions.filter(tx => tx.hash !== addressOrHash); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction: {\n        [this._system === 'ethereum' ? 'hash' : 'txid']: addressOrHash,\n        id: addressOrHash,\n        status: 'unsubscribed'\n      }\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n\nvar version = \"2.1.5\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nasync function processQueue() {\n  this._processingQueue = true;\n\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  while (this._queuedMessages.length > 0) {\n    // small wait to allow response from server to take affect\n    await wait(1);\n\n    if (this._waitToRetry !== null) {\n      // have been rate limited so wait\n      await this._waitToRetry;\n      this._waitToRetry = null;\n    }\n\n    const msg = this._queuedMessages.shift();\n\n    const delay = this._limitRules.duration / this._limitRules.points * 1000;\n    await wait(delay);\n\n    this._socket.send(msg);\n  }\n\n  this._processingQueue = false;\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId,\n    retryMs,\n    limitRules,\n    blockedMsg\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit')) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      transaction,\n      eventCode,\n      contractCall\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      eventCode,\n      contractCall\n    } : { ...transaction,\n      eventCode\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this._watchedTransactions = this._watchedTransactions.map(tx => {\n        if (tx.hash === transaction.originalHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this._watchedAccounts.find(ac => ac.address === watchedAddress);\n\n      const emitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this._watchedTransactions.find(tx => tx.hash === transaction.hash || transaction.txid);\n\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date(),\n    dappId: this._dappId,\n    version,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  });\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string'\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nconst DEFAULT_NAME = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass Blocknative {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      dappId,\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_NAME,\n      networkId,\n      transactionHandlers = [],\n      apiUrl,\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws\n    } : {});\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = CryptoEs.SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._watchedTransactions = [];\n    this._watchedAccounts = [];\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n    this._queuedMessages = [];\n    this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n    this._waitToRetry = null;\n    this._processingQueue = false;\n    this._processQueue = processQueue.bind(this);\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nfunction onReopen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n\n  this._watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\nexport default Blocknative;\n"]},"metadata":{},"sourceType":"module"}